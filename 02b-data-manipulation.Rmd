# 数据操作

## 集合运算


## 正则匹配

以 CRAN 日志数据为例

- R 包开发者

```{r}
library(magrittr)
gsub(
  " <([^<>]*)>", "",
  lapply(.packages(TRUE), maintainer)
  %>%
    unlist()
) %>% 
  unique() %>% 
  sort() %>% 
  tail(10)
```

## order 和 sort


## which

向量和矩阵中的操作

## by


## with 和 within


## apply 

## aggregate

## Map 和 Reduce

openxlsx 
拆分、映射计算，合并

```r
## Load dependencies
if (!require('openxlsx')) install.packages('openxlsx')
library('openxlsx')
 
## Split data apart by a grouping variable;
##   makes a named list of tables
dat <- split(mtcars, mtcars$cyl)
dat
 
 
## Create a blank workbook
wb <- createWorkbook()
 
## Loop through the list of split tables as well as their names
##   and add each one as a sheet to the workbook
Map(function(data, name){
 
    addWorksheet(wb, name)
    writeData(wb, name, data)
 
}, dat, names(dat))
 
 
## Save workbook to working directory
saveWorkbook(wb, file = "example.xlsx", overwrite = TRUE)
```



## embed

## split 和 cut

findInterval


## dplyr

参考 <https://d.cosx.org/d/419974-r-markdown-sql>

````markdown
`r ''````{r setup}
library(DBI)
library(RMySQL)
# 这里的数据库链接信息我改了
db <- dbConnect(MySQL(),
                   dbname='dbtest',
                   username='user_test',
                   password='password',
                   host='10.10.101.10',
                   port=3306
)
# 创建默认连接
knitr::opts_chunk$set(connection = "db")
# 设置字符，以免中文查询乱码
dbSendQuery(db,'SET NAMES utf8')
# 设置日期变量，以运用在SQL中
idate <- "2018-05-03" 
请忽略我 
```
````

SQL中使用R的变量并将结果输出为数据框

````markdown
`r ''````{sql, output.var="data_output"}

SELECT * FROM user_table where date_format(created_date,'%Y-%m-%d')>=?idate  
请忽略我
```
````

以上代码会将SQL的运行结果存在 `data_output` 这是数据库中。

````markdown
`r ''````{sql, code=readLines("你的脚本.sql")}
```
````

如果SQL比较长，为了代码美观，把带有变量的SQL保存为.sql脚本，
那怎么在SQL的chunk中直接导入SQL文件
