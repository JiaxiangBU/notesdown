# 绘图 {#plot}

```{r setup, include = FALSE}
Pkgs <- c(
  "cranlogs", "ggthemes", "webp", "rsvg",
  "pdftools", "magick",
  "ISLR",
  "tidyverse","ggrepel",
  "leaflet","rbokeh","plotly","highcharter"
)
if (length(setdiff(Pkgs, .packages(TRUE))) > 0) {
  install.packages(setdiff(Pkgs, .packages(TRUE)))
}

if (!"spDataLarge" %in% .packages(TRUE)) {
  install.packages("spDataLarge",
    repos = "https://nowosad.github.io/drat/",
    type = "source"
  )
}
```


- Claus O. Wilke 新书：数据可视化基础 [Fundamentals of Data Visualization](http://serialmentor.com/dataviz/) 全 R/ggplot2 实现

```bash
sudo apt-get install libwebp-dev libpoppler-cpp-dev
```

## plot {#base}

```{r run-length-hist, fig.cap='游程直方图', fig.showtext=TRUE}
set.seed(2018) 
n <- 2^16
x <- runif(n,0,1)
delta <- 0.01
len <- diff(c(0,which(x < delta),n+1))-1
ylim <- seq( 0, 1800, by = 300)
xlim <- seq( 0, 100, by = 20)
p <- hist(len[len < 101], breaks = -1:100+0.5, plot = FALSE)
par(mar = c(2,2,.5,.5))
plot(p, xlab = '间距', ylab = '频数', axes = FALSE, 
     col = "lightblue", border = "white", main = "")	 
axis( 1, labels = xlim, at = xlim, las = 1) # x 轴
axis( 2, labels = ylim, at = ylim, las = 0) # y 轴
box(col="gray")
# 添加线性回归线
xx <- seq.int(from = 0, to = 100, by = 1)
xy <- p$counts
options(digits = 2)
fit <- lm(xy~xx)
abline(fit, col = 'red')
b = coef(fit)
# mtext(paste0( "Y = ", paste0(paste0(b[1], b[2]),"x") ), side = 3, cex = 2)
```

还你一个清爽的世界，统计之都文章 [漫谈条形图](https://cosx.org/2017/10/discussion-about-bar-graph/)

```{r beautiful-barplot,fig.cap="条形图"}
data(NCI60, package = "ISLR") # 加载数据
myData <- sort(table(NCI60$labs), decreasing = TRUE)
par(mar = c(2, 7, 1, 1))
barCenters <- barplot(myData,
  col = "lightblue", axes = FALSE,
  axisnames = FALSE, horiz = TRUE, border = "white"
)
text(
  y = barCenters, x = par("usr")[3],
  adj = 1, labels = names(myData), xpd = TRUE
)
axis(1, labels = seq(0, 9, by = 1), at = seq(0, 9, by = 1), las = 1, col = "gray")
```

plot 作为一个泛型函数，对于不同的输入数据类型，会自动匹配不同的绘图函数，默认的有

```{r}
methods(plot)
```


```{r nice-plot,echo=FALSE, fig.cap='丰富的方法', fig.width=8,fig.height=9,out.width="80%"}
source(file = "code/plot.R", local = TRUE)
```

```{r, fig.cap="raster 图形"}
library(raster)
library(sp)
library(spDataLarge)
plot(elevation, asp = NA)
```

## ggplot {#ggplot}


ggplot2 有很多绘图函数

```{r}
library(ggplot2)
grep('^(geom_)', ls('package:ggplot2'), value = TRUE)
grep('^(stat_)', ls('package:ggplot2'), value = TRUE)
```

rattle 下载量时序图

```{r log,fig.showtext=TRUE}
library(ggplot2)
library(cranlogs)
library(ggthemes)
pkgs_down <- cran_downloads(package = "rattle", from = Sys.Date() - 365 * 5, to = Sys.Date())
ggplot(pkgs_down, aes(x = date, y = count, colour = package)) +
  geom_line() +
  geom_point(size = 1.5) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  ylim(c(0, 1500)) +
  scale_colour_brewer(palette = "Set1") +
  # scale_color_fivethirtyeight("") +
  # theme_fivethirtyeight() +
  labs(
    subtitle = paste("最近更新日期:", Sys.Date()),
    title = "Rattle 最近5年每日下载量",
    caption = " 数据源: http://cran-logs.rstudio.com/ "
  ) +
  theme_minimal(base_size = 10.54, base_family = "source-han-serif-cn")
```

给线条添加注释和标签，这个功能有时候比图例更加漂亮

```{r add-label-ggrepel, fig.cap="添加标签"}
# 出自 https://gist.github.com/EmilHvitfeldt/acb849a6135a21426c260850cf0f461b
# Horizontal annotations with ggrepel and ggplot2
library(tidyverse)
library(ggrepel)
data <- tibble(
  x = seq_len(100),
  y = cumsum(rnorm(100))
)

anno_data <- data %>%
  filter(x %% 25 == 10) %>%
  mutate(text = "text")

data %>%
  ggplot(aes(x, y)) +
  geom_line() +
  geom_label_repel(aes(label = text),
    data = anno_data,
    direction = "y",
    nudge_y = c(-5, 5, 5, 5)
  ) +
  theme_minimal()
```



## tikz {#tikz}

如图 \@ref(fig:latex-tikz) 所示，模板存放在 `tikz/tikz2pdf.tex`

```{r latex-tikz, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.cap='tikz 图形', engine.opts = list(template = "tikz/tikz2pdf.tex")}
\begin{tikzpicture}[scale=.7]
\draw [fill=gray!30,very thick] (0,-1) rectangle (5,1);
\draw [very thick] (5, 0) -- (13,0);
\node [below] at (2,-1) {\large Hello};
\node [below, align=center] at (0,-1) {\large Two\\ lines};
\end{tikzpicture}
```

一幅纯 tikz 代码绘制的图形，代码如下

```{r import-tikze-code}
cat(readLines("tikz/mini-demo.tex", encoding = "UTF-8"), sep = "\n")
```

```{r mini-tikz-demo,echo=FALSE,fig.cap="一幅迷你 tikz 图形"}
knitr::include_graphics(path = "tikz/mini-demo.png")
```

```{r, dev='tikz', fig.width=4.4, fig.height=3.3, out.width="90%",eval = !knitr::is_html_output(),fig.ext='tex', tikz2png='-density 300',fig.cap='tikz 图形'}
par(mar = c(4.5, 4, .1, .1))
hist(x, main='', xlab='$x$ (how the fonts look like here?)',
  ylab='$\\hat{f}(x) = \\frac{1}{nh}\\sum_{i=1}^n \\cdots$')
```

## JS

基于 JS 动态库的 R 包 leaflet [@R-leaflet]，ggvis ， rbokeh [@R-rbokeh] 和 plotly [@R-plotly] ，我比较喜欢 highcharter [@R-highcharter]，美观高效，还活跃开发中。

```{r highcharter, eval= knitr::is_html_output(), fig.cap="highcharter 图形",cache=FALSE}
library("highcharter")
data(diamonds, mpg, package = "ggplot2")

hchart(mpg, "scatter", hcaes(x = displ, y = hwy, group = class))
```


```{r rbokeh, eval = knitr::is_html_output(), fig.cap="rbokeh 图形",warning=FALSE,message=FALSE,cache=FALSE}
library(rbokeh)
h <- figure(width = 600, height = 400) %>%
  ly_hist(eruptions, data = faithful, breaks = 40, freq = FALSE) %>%
  ly_density(eruptions, data = faithful)
h
```


```{r plotly, eval = knitr::is_html_output(), fig.cap="plotly 图形",cache=FALSE}
library(plotly)
plot_ly(z = ~volcano, type = "surface")
```


## 位图


## 矢量图

图片导入，导出，转化，批量转化

导入 SVG 格式的图片, rsvg [@R-rsvg] 批量转化 svg 文件为 pdf 文件

```r
library(rsvg)
tmp <- "figure/Ink" # svgs 存放目录
input_paths <- paste0(tmp, "/", list.files(tmp))
output_paths <- paste0("figure/pdf", "/", gsub("svg", "pdf", list.files(tmp)))

for (i in seq(length(list.files(tmp)))) {
  rsvg_pdf(input_paths[i], file = output_paths[i])
}
```

- pdftools [@R-pdftools] 用于文本提取，渲染和转化 PDF 文档

- magick 的简单使用，如插入 Inkscape 图标，如图\@ref(fig:inkscape-logo)

```{r inkscape-logo,fig.cap="Inkscape 图标", echo = FALSE, out.width="25%"}
# magick::image_read_svg(path = "diagrams/inkscape.svg")
knitr::include_graphics(path = paste0("diagrams/inkscape", ext))
```

Inkscape^[<https://inkscape.org/zh/>] 是替代 Adobe Illustrator（简称 AI） 最佳工具，没有之一。开源免费，功能齐全，更新快，跨平台。尤其不用面临如图\@ref(fig:ai-error)所示的兼容性问题，说白了，就是厂家在不停地刷版本号，要用户掏钱升级，我早年间也是 Adobe 的忠实粉丝，通过校园先锋以学生身份买了好几套产品，后来看透了这一切，又找到了开源的 Inkscape \index{Inkscape}，现在我没有理由去升级 AI 了，我的电脑现在装的还都是 CS6 系列。

```{r ai-error,fig.cap="兼容性错误", echo = FALSE}
knitr::include_graphics(path = "diagrams/AICC.png")
```

`r if(knitr::is_html_output()) "最后欣赏来自官网的几个作品^[图片来自 <https://inkscape.org/en/gallery/>]" `

```{r ink-work,fig.cap="作品欣赏", echo = FALSE,out.width="45%", eval= knitr::is_html_output() }
knitr::include_graphics(path = paste0(
  "diagrams/",
  paste0(
    c("space-ink", "about-ink"), ".svg"
  )
))
```

## 优化

optipng 是一个非常好的图片压缩、优化工具

现在，我们设置 chunk 选项 `optipng` 为非空(non-`NULL`)的值，例如，`''` 去激活这个 hook （益辉称之为钩子，这里勾的是 optipng 这个图片优化工具）

```{r use-optipng, optipng='',fig.cap="优化"}
set.seed(123)
qplot(rnorm(1e3), rnorm(1e3))
```

同一幅图，但是没有优化

```{r no-optipng, ref.label='use-optipng',fig.cap="没有优化"}
```

同一幅图，但是使用最高级别的优化 (传递 `-o7` 参数给 `optipng`):

```{r optipng-o7, ref.label='use-optipng', optipng='-o7',fig.cap="最强优化"}
```

## 裁剪

pdfcrop 可将 PDF 图片中留白的部分裁去，再也不用纠结 par 了

```{r pdfcrop, fig.cap="pdfcrop 裁剪白边", crop = TRUE,echo=FALSE}
knitr::include_graphics(path = "figures/map_usa_unemp.pdf")
```
