\documentclass[10pt,compress]{beamer}
\input{BeamerSetting}


\begin{document}

<<include=FALSE>>=
# path<-"C:\\Users\\Xiangyun Huang\\Desktop\\beamerSlide\\optimization\\"
# setwd(path)
# packages<-c("ggplot2","BB")
# write_bib(packages,file = "optimization.bib")
library(knitr)
# knit_theme$set("print")
knit_theme$set("fruit")
options(prompt=">")
# op<-par(mar=c(2, 2 ,1, 0.2))
# 设置图片尺寸
# fig.width=10,fig.height=7
# out.width='.8\\linewidth',out.height='.6\\linewidth'
opts_chunk$set(size="scriptsize",prompt=TRUE,comment=NA)
@

\frame{\titlepage}

\logo{\includegraphics[height=0.09\textwidth]{Logo/CUMTB_SS}}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{目录}
    \tableofcontents[currentsection] %不隐藏子章节 subsection
    % \tableofcontents[currentsection,hideallsubsections]
  \end{frame}
}


\section{R语言}


\subsection{安装R包}

\begin{frame}[fragile]
\frametitle{安装R包}
从指定网站安装R包
<<eval=FALSE>>=
install.packages("ggplot2",repos = "https://mirrors.tuna.tsinghua.edu.cn/CRAN/")
install.packages("pim",repos = "http://www.r-forge.r-project.org/",
                 lib = "D:/library/")
@
一行命令安装cran上所有的Packages
<<eval=FALSE,size="scriptsize">>=
install.packages(setdiff(available.packages()[,1],
                         .packages(all.available = TRUE)))
@
安装Bioconductor上的R包
<<eval=FALSE,size="scriptsize">>=
source("https://bioconductor.org/biocLite.R")
library(BiocInstaller)
biocLite("ggtree")
@
安装Github上的R包
<<eval=FALSE,size="scriptsize">>=
library(devtools)
install_github("ropensci/aRxiv")
@
\end{frame}


\begin{frame}[fragile]
\frametitle{安装注意几项}
\begin{description} 
  \item[依赖问题] 主要针对离线安装和源码编译安装
  \item[平台问题] 有些R包只能装在类unix操作系统上
  \item[软件问题] 有些R包要求相应R软件版本
  \item[特定库依赖] 如gputools包依赖cuda库
\end{description}
<<comment=NA,size="scriptsize">>=
# OS information
Sys.info()
@
\end{frame}

\begin{frame}[fragile]
\frametitle{R软件信息}
<<comment=NA,size="scriptsize",prompt=TRUE>>=
sessionInfo()
@
\end{frame}


\subsection{获取数据}
\begin{frame}[fragile]
\frametitle{R软件系统自带的数据集}
<<eval=FALSE,size="scriptsize">>=
# view R data sets
length(data(package = .packages(all.available = TRUE))$results[,3])
## [1] 21091
@
<<warning=FALSE,size="scriptsize">>=
# extended packages
library(ggplot2)
data("diamonds")
head(diamonds)
@
\end{frame}

\subsection{撬开R}
\begin{frame}[fragile]
\frametitle{谈谈对象}
<<>>=
class(diamonds) #Object Classes
str(diamonds) #Compactly Display the Structure of an Arbitrary R Object 
# mode(diamonds) #The (Storage) Mode of an Object
# typeof(diamonds) #The Type of an Object
# attributes(diamonds) #Object Attribute Lists
@
\end{frame}


\begin{frame}[fragile]
\frametitle{pryr包撬开R的底层}
\begin{itemize}
\item pryr: Useful tools to pry back the covers of R and understand the language at a deeper level.
\end{itemize}
<<>>=
c(is.list(diamonds),is.matrix(diamonds))
c(is.vector(diamonds),is.numeric(diamonds))
c(is.array(diamonds),is.data.frame(diamonds))
@
\end{frame}

\begin{frame}[fragile]
\frametitle{撬开tabulate函数}
<<size="scriptsize">>=
tabulate
@
\end{frame}

\begin{frame}[fragile]
\frametitle{撬开tabulate函数}
<<eval=FALSE,engine='Rcpp'>>=
library(pryr)
show_c_source(.Internal(tabulate(bin,nbins)))
SEXP attribute_hidden do_tabulate(SEXP call, SEXP op, SEXP args, SEXP rho)
{
    checkArity(op, args);
    SEXP in = CAR(args), nbin = CADR(args);
    if (TYPEOF(in) != INTSXP)  error("invalid input");
    R_xlen_t n = XLENGTH(in);
    /* FIXME: could in principle be a long vector */
    int nb = asInteger(nbin);
    if (nb == NA_INTEGER || nb < 0)
      error(_("invalid '%s' argument"), "nbin");
    SEXP ans = allocVector(INTSXP, nb);
    int *x = INTEGER(in), *y = INTEGER(ans);
    if (nb) memset(y, 0, nb * sizeof(int));
    for(R_xlen_t i = 0 ; i < n ; i++)
      if (x[i] != NA_INTEGER && x[i] > 0 && x[i] <= nb) y[x[i] - 1]++;
    return ans;
}
@
\end{frame}

\begin{frame}[fragile]
\frametitle{撬开plot}
<<size="scriptsize">>=
methods(plot)
@
\end{frame}


\begin{frame}[fragile]
% \frametitle{plot的方法}
<<echo=FALSE,size="tiny",comment=NA>>=
print(attr(methods(plot),"info"))
@
\end{frame}


\section{统计绘图}
\subsection{graphics包}

\begin{frame}[fragile]
\frametitle{plot函数--pch}
\framesubtitle{点}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
plot(c(0,5),c(0,4.2),type = "n",xlab = "",ylab = "",axes = FALSE,main = "26 shaps of points")
# plot(c(0,5),c(0,6),type = "n",xlab = "",ylab = "")
j=0
for(i in seq(26)){
  points(j,(i-1)%%5,pch=i-1,cex=3)
  if(i%%5==0) j=j+1 
}
@
\end{frame}

\begin{frame}[fragile]
\frametitle{plot函数--lty--lwd}
\framesubtitle{线}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
x <- stats::rnorm(50)
opar <- par(bg = "white")
plot(x, ann = FALSE, type = "n")
abline(h = 0, col = gray(.90))
lines(x, col = "green4", lty = "dotted")
points(x, bg = "limegreen", pch = 21)
title(main = "Simple Use of Color In a Plot",
      xlab = "Just a Whisper of a Label",
      col.main = "blue", col.lab = gray(.8),
      cex.main = 1.2, cex.lab = 1.0, font.main = 4, font.lab = 3)
par(opar)
@
\end{frame}


\begin{frame}[fragile]
\frametitle{调色板--连续型}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
library(RColorBrewer)
display.brewer.all(type = "seq")
@
\end{frame}


\begin{frame}[fragile]
\frametitle{调色板--极端型}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
display.brewer.all(type = "div")
@
\end{frame}

\begin{frame}[fragile]
\frametitle{调色板--离散型}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
display.brewer.all(type = "qual")
@
\end{frame}


\begin{frame}[fragile]
\frametitle{举个栗子}
<<fig.align='default',fig.width=10,fig.height=6.5,size="scriptsize">>=
barplot(sample(seq(20),6,replace = T),col=brewer.pal(11, "BrBG")[3:8])
@
<<include=FALSE,eval=FALSE>>=
# suppressPackageStartupMessages(library(pbdDEMO)) #去除加载包时提示的信息
barplot(sample(seq(20),11,replace = T),col=brewer.pal(11, "BrBG"))
@
\end{frame}

\begin{frame}[fragile]
\frametitle{再举个栗子}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
data(VADeaths)
op<-par(mfrow=c(2,3))
hist(VADeaths,breaks=10, col=brewer.pal(3,"Set3"),main="Set3 3 colors")
hist(VADeaths,breaks=3 ,col=brewer.pal(3,"Set2"),main="Set2 3 colors")
hist(VADeaths,breaks=7, col=brewer.pal(3,"Set1"),main="Set1 3 colors")
hist(VADeaths,breaks= 2, col=brewer.pal(8,"Set3"),main="Set3 8 colors")
hist(VADeaths,col=brewer.pal(8,"Greys"),main="Greys 8 colors")
hist(VADeaths,col=brewer.pal(8,"Greens"),main="Greens 8 colors")
par(op)
@
\end{frame}

\begin{frame}[fragile]
\frametitle{继续举个栗子}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
plot(iris[,-5],col=brewer.pal(3,"Set1"))
@
\end{frame}


\begin{frame}[fragile]
\frametitle{三维图--persp}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
# 3-D plots
mu1<-0 # setting the expected value of x1
mu2<-0 # setting the expected value of x2
s11<-10 # setting the variance of x1
s12<-15 # setting the covariance between x1 and x2
s22<-10 # setting the variance of x2
rho<-0.5 # setting the correlation coefficient between x1 and x2
x1<-seq(-10,10,length=41) # generating the vector series x1
x2<-x1 # copying x1 to x2

f<-function(x1,x2)
  {
    term1<-1/(2*pi*sqrt(s11*s22*(1-rho^2)))
    term2<--1/(2*(1-rho^2))
    term3<-(x1-mu1)^2/s11
    term4<-(x2-mu2)^2/s22
    term5<--2*rho*((x1-mu1)*(x2-mu2))/(sqrt(s11)*sqrt(s22))
    term1*exp(term2*(term3+term4-term5))
  } # setting up the function of the multivariate normal density
  #
z<-outer(x1,x2,f) # calculating the density values
#
persp(x1, x2, z,main="Two dimensional Normal Distribution",
      sub=expression(italic(f)~(bold(x))==frac(1,2~pi~sqrt(sigma[11]~sigma[22]~(1-rho^2)))~phantom(0)^bold(.)~exp~
                       bgroup("{",list(-frac(1,2(1-rho^2)),
                       bgroup("[", frac((x[1]~-~mu[1])^2,
                              sigma[11])~-~2~rho~frac(x[1]~-~mu[1],
                              sqrt(sigma[11]))~ frac(x[2]~-~mu[2],
                              sqrt(sigma[22]))~+~frac((x[2]~-~mu[2])^2, sigma[22]),"]")),"}")),
      col="lightgreen",theta=30, phi=20,r=50,d=0.1,
      expand=0.5,ltheta=90, lphi=180,shade=0.75,ticktype="detailed",nticks=5) # produces the 3-D plot

mtext(expression(list(mu[1]==0,mu[2]==0,sigma[11]==10,sigma[22]==10,sigma[12]==15,rho==0.5)), side=3) 
# adding a text line to the graph
@
\end{frame}

\begin{frame}[fragile]
\frametitle{添加数学公式}
<<echo=FALSE,fig.align='default',fig.width=12,fig.height=7>>=
op<-par(mfrow = c(1, 2))
curve(dnorm, from = -3, to = 3, n = 1000, main = "Normal Probability Density Function")
text(-2, 0.3, expression(f(x) == paste(frac(1, sqrt(2 * pi * sigma^2)),
    " ", e^{
        frac(-(x - mu)^2, 2 * sigma^2)
    })), cex = 1.2)
x <- dnorm(seq(-3, 3, 0.001))
plot(seq(-3, 3, 0.001), cumsum(x)/sum(x), type = "l", col = "blue",
    xlab = "x", main = "Normal Cumulative Distribution Function")
text(-1.5, 0.7, expression(phi(x) == paste(frac(1, sqrt(2 * pi)),
    " ", integral(e^(-t^2/2) * dt, -infinity, x))), cex = 1.2)
par(op)
@
\end{frame}



\begin{frame}[fragile]
\frametitle{anscombe数据}
<<comment=NA,echo=FALSE,fig.align='center',fig.width=10,fig.height=7>>=
rm(list = ls())
data("anscombe")
attach(anscombe)
op<-par(mfrow=c(2,2),omi=c(0,0,0.5,0),mar=c(4,4,1,1))
plot(y1~x1,col="blue",pch=19,xlab=expression(x[1]),ylab = expression(y[1]))
fit1<-lm(y1~x1)
abline(fit1,col="red",lwd=2)
legend( "topleft",legend = c(expression(y[1]==3.00+0.50*x[1])),col = "red",lwd = 2,cex = 1)

plot(y2~x1,col="blue",pch=19,xlab=expression(x[1]),ylab = expression(y[2]))
fit2<-lm(y2~x1)
abline(fit2,col="red",lwd=2)
legend( "topleft",legend = c(expression(y[2]==3.00+0.50*x[1])),col = "red",lwd = 2,cex = 1)

plot(y3~x1,col="blue",pch=19,xlab=expression(x[1]),ylab = expression(y[3]))
fit3<-lm(y3~x1)
abline(fit3,col="red",lwd=2)
legend( "topleft",legend = c(expression(y[3]==3.00+0.50*x[1])),col = "red",lwd = 2,cex = 1)

plot(y4~x4,col="blue",pch=19,xlab=expression(x[4]),ylab = expression(y[4]))
fit4<-lm(y4~x4)
abline(fit4,col="red",lwd=2)
legend( "topleft",legend = c(expression(y[4]==3.00+0.50*x[4])),col = "red",lwd = 2,cex = 1)

mtext(expression( paste( hat(sigma)^2==1.531 ,",","Multiple ",
                         R^2 == 0.667,",","Adjusted ", R^2==0.629 ) ),line = 1,outer = TRUE)
detach(anscombe)
par(op)
@
\end{frame}

\subsection{ggplot2包}

\begin{frame}[fragile]
\frametitle{barplot}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
ICUData<-read.csv(file = "data/ICUData.csv")

library(RColorBrewer)
cols<-brewer.pal(n=5,name = "Set1")

barplot(table(ICUData$surgery),main = "Types of surgery",
        ylab = "Absolute frequency",col = cols)

@
\end{frame}

\begin{frame}[fragile]
\frametitle{barplot}
<<echo=FALSE,fig.align='default',fig.width=10,fig.height=7>>=
library(ggplot2)
ggplot(ICUData,aes(x=surgery))+
  geom_bar(aes(y=100*(..count..)/sum(..count..)),
           width = 0.5,fill=cols)+
  ggtitle("Types of surgery")+ylab("Relative frequency in %")
@
\end{frame}




\section{统计计算}
\subsection{统计量计算}

\begin{frame}[fragile]
\frametitle{多元概率分布函数}
The multivariate $t$ distribution (MVT) is given by
$$T(\mathbf{a},\mathbf{b},\Sigma,\nu)=\frac{2^{1-\frac{\nu}{2}}}{\Gamma(\frac{\nu}{2}) } \int_{0}^{\infty} s^{\nu-1}e^{-\frac{s^2}{2}} \Phi(\frac{s\mathbf{a}}{\sqrt{\nu}},\frac{s\mathbf{b}}{\sqrt{\nu}},\Sigma)ds $$

multivariate normal distribution function (MVN) 
$$ \Phi(\mathbf{a},\mathbf{b},\Sigma)=\frac{1}{\sqrt{|\Sigma|(2\pi)^m}} \int_{a_1}^{b_1}\!\int_{a_2}^{b_2}\!\cdots\!\int_{a_m}^{b_m} e^{-\frac{1}{2}x^\top\Sigma^{-1}x}dx$$
$x=(x_1,x_2,\dots,x_m)^\top,-\infty \le a_i \le b_i \le \infty$ for all $i,$ and $\Sigma$ is a positive semi-definite symmetric $m \times m$ matrix
\end{frame}

\begin{frame}[fragile]
\frametitle{计算多元正态分布的概率}
<<size="scriptsize">>=
library(mvtnorm) 
library(matrixcalc) 
path<-"C:/Users/Xiangyun Huang/Desktop/optimization/"
setwd(path)
sigma <- read.csv(file="data/sigma1.csv",header=F, sep=",") 
mat<-matrix(0,nrow = nrow(sigma),ncol = ncol(sigma))
sigma <- as.matrix(sigma)
attributes(sigma)<-attributes(mat)
# str(sigma)
# is.symmetric.matrix(sigma) 
# is.positive.definite(sigma) 
m = nrow(sigma) 
Fn = pmvnorm(lower=rep(-Inf, m), upper=rep(0, m), 
             mean=rep(0, m), sigma =sigma) 
Fn
@
\end{frame}

\begin{frame}[fragile]
\frametitle{多元$t$分布分位数计算}
<<size="scriptsize">>=
n <- c(26, 24, 20, 33, 32)
V <- diag(1/n); df <- 130
C <- matrix(c(1,1,1,0,0,-1,0,0,1,0,
       0,-1,0,0,1,0,0,0,-1,-1,
       0,0,-1,0,0),ncol=5)
cv <- C %*% V %*% t(C) ## covariance matrix
dv <- t(1/sqrt(diag(cv)))
cr <- cv * (t(dv) %*% dv) ## correlation matrix
delta <- rep(0,5)
Tn<-qmvt(0.95, df = df, delta = delta, corr = cr, 
     abseps = 0.0001,maxpts = 100000, tail = "both")
Tn
@
\end{frame}


\subsection{线性模型}

\begin{frame}[fragile]
\frametitle{优化分类}
  \begin{enumerate}
    \item 无约束优化  
      \iitem optimize(optimise) 一元函数极值(黄金分割搜索算法)
      \iitem nlm 多元非线性函数极值(Newton型算法)
      \iitem optim 多元非线性函数极值(Nelder-Mead算法、拟牛顿法、共轭梯度算法、模拟退火算法) 
      \iitem nlminb 无约束优化
      \iitem BB\textsuperscript{\cite{R-BB}}和numDeriv包 高维非线性目标函数优化(Barzilai-Borwein算法)
    \item 约束优化
      \iitem 箱式(box)约束：nlminb和BB包
      \iitem 线性不等式约束：constrOptim 障碍罚函数方法
      \iitem 非线性约束：暂无
  \end{enumerate} 
\end{frame}

%% nloptr包 
%% NlcOptim包 序列二次规划SQP 
%% Rsolnp包 增广拉格朗日算法General Non-linear Optimization 
%% nlmrt包  非线性最小二乘解Functions for Nonlinear Least Squares Solutions
\begin{frame}[fragile]
\frametitle{无约束优化}
    \begin{equation}
    \begin{aligned}
      \label{eqn:LR}
     Q_{1} &= \min_{\beta_{0},\beta_{1}} \sum_{i=1}^{n}|{\beta_{0}+\beta_{1}x_{i}-y_{i}}| \\
     Q_{2} &= \min_{\beta_{0},\beta_{1}} \sum_{i=1}^{n}(\beta_{0}+\beta_{1}x_{i}-y_{i})^{2} \\
     Q_{3} &= \min_{\beta_{0},\beta_{1}} \max_{1\le i\le n} |\beta_{0}+\beta_{1}x_{i}-y_{i}|
     \end{aligned}
    \end{equation}
\end{frame}

\begin{frame}[fragile]
\frametitle{举例子}
\begin{columns}
\column{0.4\textwidth}
<<message=FALSE,warning=FALSE>>=
library(dplyr)
tbl_df(cars)
@
\column{0.6\textwidth}
<<echo=FALSE,fig.width=6,fig.height=5.6>>=
plot(cars,pch=16,col="blue")
@
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{回归系数}
<<>>=
## Linear Regression with L1 Regularization
reg1fun<-function(beta,data){
  sum(abs(data[,2]-beta[1]-beta[2]*data[,1]))
}
optim(c(0,4),reg1fun,data=cars)$par
## Linear Regression with L2 Regularization
reg2fun<-function(beta,data){
  sum((data[,2]-beta[1]-beta[2]*data[,1])^2)
}
optim(c(0,4),reg2fun,data=cars)$par
## Linear Regression with minimax 
reg3fun<-function(beta,data){
  max(abs(data[,2]-beta[1]-beta[2]*data[,1])) 
}
optim(c(0,4),reg3fun,data=cars)$par
@
\end{frame}

\begin{frame}[fragile]
\frametitle{线性回归lm}
<<include=FALSE>>=
## Linear Regression in R
## Least Square 
fit2<-lm(dist~speed,data = cars)
summary(fit2)
@
\begin{table}[!htbp] \footnotesize \centering  
  \caption{Regression Results} 
  \label{} 
\begin{tabular}{@{\extracolsep{5pt}}lc} 
\\[-1.8ex]\hline 
\hline \\[-1.8ex] 
 & \multicolumn{1}{c}{\textit{Dependent variable:}} \\ 
\cline{2-2} 
\\[-1.8ex] & dist \\ 
\hline \\[-1.8ex] 
 speed & 3.932$^{***}$ \\ 
  & (0.416) \\ 
  & \\ 
 Constant & $-$17.579$^{**}$ \\ 
  & (6.758) \\ 
  & \\ 
\hline \\[-1.8ex] 
Observations & 50 \\ 
R$^{2}$ & 0.651 \\ 
Adjusted R$^{2}$ & 0.644 \\ 
Residual Std. Error & 15.380 (df = 48) \\ 
F Statistic & 89.567$^{***}$ (df = 1; 48) \\ 
\hline 
\hline \\[-1.8ex] 
\textit{Note:}  & \multicolumn{1}{r}{$^{*}$p$<$0.1; $^{**}$p$<$0.05; $^{***}$p$<$0.01} \\ 
\end{tabular} 
\end{table} 
\end{frame}


\begin{frame}[fragile]
\frametitle{线性回归}
<<echo=FALSE,fig.width=10,fig.height=7>>=
plot(cars,pch=16,col="blue")
abline(fit2,col="red")
@
\end{frame}

\begin{frame}[fragile]
\frametitle{回归诊断}
<<echo=FALSE,fig.width=10,fig.height=7>>=
op <- par(mfrow = c(2,2), oma = c(0,0,1,0))
plot(fit2)
par(op)
@
\end{frame}

\subsection{参数估计}

\begin{frame}[fragile]
\frametitle{$\Gamma$分布参数估计}
The Gamma distribution with parameters shape = $a$ and scale = $s$ has density
$$f(x)=\frac{1}{s^a\Gamma(a)}x^{a-1} e^{-\frac{x}{s}}$$
$$E(x)=as,Var(x)=as^2$$
矩估计：用样本均值$\bar{x}$替换总体均值$E(x)$，样本方差$S^2$替换总体方差$Var(x)$
$$\hat{a}_{ME}=\frac{\bar{x}^2}{S^2},\hat{s}_{ME}=\frac{S^2}{\bar{x}}$$
\end{frame}

\begin{frame}[fragile]
\frametitle{最大似然估计}
似然函数$$L(x_1,x_2,\dots,x_n;a,s)=(\frac{1}{s^a\Gamma(a)})^n(\prod_{i=1}^n{x_i})^{a-1}e^{-\frac{\sum_{i=1}^{n}x_i}{s}}$$
对数似然函数$$logL(x_1,x_2,\dots,x_n;a,s)=-n(alogs+log\Gamma(a))+(a-1)\sum_{i=1}^{n}log x_i -\frac{1}{s}\sum_{i=1}^{n}x_i $$
似然方程组
\[
\begin{cases}
\frac{\partial logL}{\partial a}&= -n[logs +(log\Gamma(a))']+\sum_{i=1}^{n}log x_i = 0 \\
\frac{\partial logL}{\partial s}&= -\frac{na}{s}+\frac{\sum_{i=1}^{n}x_i}{s^2} = 0 
\end{cases}
\]
\end{frame}


\begin{frame}[fragile]
\frametitle{最大似然估计}
将$s=\frac{1}{na}\sum_{i=1}^{n}x_i$代入似然方程组，可得
\begin{align}
loga-[log\Gamma(a)]'=\frac{1}{n}\sum_{i=1}^{n}log x_i -log(\frac{1}{n}\sum_{i=1}^{n}x_i)
\end{align}
其中
\begin{align}
\Gamma(a)    &= \int_0^{+\infty}e^{-t}t^{a-1}dt \notag \\
[\Gamma(a)]' &= \int_0^{+\infty}e^{-t}t^{a-1}log tdt \notag
\end{align}
似然方程组的求解问题，归结为求一元非线性方程(2).调用Brent算法\textsuperscript{\cite{Brent}}求解

\end{frame}



\begin{frame}[fragile]
\frametitle{数值模拟结果}
<<r MLE>>=
set.seed(1234)
x<-rgamma(100,shape = 3/2,scale = 2)
# Moment Estimation
c(mean(x)^2/var(x),var(x)/mean(x))  #shape and scale
# Maximum Likelihood Estimation
C<-log(mean(x))- mean(log(x))
Gammafun<-function(a){  
  tempfun<-function(s){
    exp(-s)*s^(a-1)*log(s)
  }
  return(tempfun)
}
myfun<-function(alpha){
  log(alpha)-C-integrate(Gammafun(alpha),lower = 0,upper = Inf)$value/gamma(alpha)
}
(a<-uniroot(myfun,interval = c(1,3))$root) #shape
mean(x)/a #scale
@
\end{frame}

<<include=FALSE>>=
rm(list = ls())
@

\section{概率算法}


\begin{frame}[fragile]
\frametitle{非凸函数}
  \begin{figure}[htb]
  \centering
  \subfloat{%
    \includegraphics[width=.3\textwidth,height=.25\textwidth]{figs/Rosenbrock}}\hfill
  \subfloat{%
    \includegraphics[width=.3\textwidth,height=.25\textwidth]{figs/Beale}}\hfill
  \subfloat{%
    \includegraphics[width=.3\textwidth,height=.25\textwidth]{figs/Levy}}\\
  \subfloat{%
    \includegraphics[width=.3\textwidth,height=.25\textwidth]{figs/Ackley}}\hfill
  \subfloat{%
    \includegraphics[width=.3\textwidth,height=.25\textwidth]{figs/Bukin}}\hfill
  \subfloat{%
    \includegraphics[width=.3\textwidth,height=.25\textwidth]{figs/Schaffer}}\\
  \caption{Rosenbrock Beale Levy Ackley Bukin Schaffer}
  \end{figure}
\end{frame}



\subsection{MC算法}

\begin{frame}[fragile]
\frametitle{介绍}
~~~~蒙特卡罗(Monte Carlo)是随机模拟的别称。Monte Carlo本是Monaco(摩纳哥)的著名赌城，
第二次世界大战期间，N.Metropolis在曼哈顿计划中取其博彩游戏和随机模拟算法之间的相似之处，
同时也为了保密起见，首次借用其名作为随机模拟算法的名称。
\begin{theorem}[定义]
如果存在自然数$\tau$，使得马氏链的转移概率矩阵$\boldsymbol{P}$满足$\boldsymbol{P}^{\tau}>0$
(这里矩阵$\boldsymbol{A}>0$表示$\boldsymbol{A}$的每个元素都严格大于0)，则称该马氏链为本原的
\end{theorem}

\begin{theorem}[时齐马氏链的遍历定理]
本原马氏链的转移概率矩阵$\boldsymbol{P}$有唯一的不变分布$\boldsymbol{\pi}$，且对任意初始分布$\boldsymbol{\nu}$，有
$$\lim_{n \rightarrow +\infty} \parallel \boldsymbol{\nu} \boldsymbol{P}^n -\boldsymbol{\pi} \parallel=0$$
\end{theorem}
\end{frame}

\begin{frame}[fragile]
\frametitle{举例子}
样本$X_1,X_2,...,X_n$抽自总体$N(\theta,1)$，现分别用样本均值$\bar{X_n}$和中位数$m_{0.5}$估计总体均值$\theta$，
得到$$\sqrt{n}(\bar{X_n}-\theta)  \overset{L}{\longrightarrow}  N(0,1)$$ 和 $$\sqrt{n}(m_{0.5}-\theta)  \overset{L}{\longrightarrow} N(0,\frac{\pi}{2})$$
\end{frame}

\begin{frame}[fragile]
\frametitle{模拟结果}
<<echo=FALSE,fig.align='center',fig.width=8,fig.height=6>>=
n=64
mu=5
simu_dist=function(n){
  x=rnorm(n,mu,1) #mu=5 size=n=64
  samp_mean<-mean(x)
  samp_median<-median(x)
  samp_min<-2*min(x)
  samp_max<-max(x)/sqrt(2)
  c(samp_mean,samp_median,samp_min,samp_max)
}
EST=replicate(1000,simu_dist(n))
# hist(EST[1,],freq = FALSE)
# hist(EST[2,],freq = FALSE)
plot(c(2,8),c(0,3.2),type = "n",xlab = "",ylab = "Density",main = expression(n==1000))
lines(density(EST[1,]),col="red",lwd=2,lty=2)
lines(density(EST[2,]),col="green",lwd=2,lty=2)
lines(density(EST[3,]),col="blue",lwd=2,lty=2)
lines(density(EST[4,]),col="black",lwd=2,lty=2)

legend( "topleft",legend = c(expression( paste(bar(x)[n])),expression( paste(m[0.5])),expression( paste(2*x[(1)])),
                             expression( paste(x[(n)]/sqrt(2))) ),
        col =c( "red","green","blue","black"),lwd = 2,lty = c(2,2,2,2),cex = 1)

@
\end{frame}

\begin{frame}[fragile]
\frametitle{Integration}
计算下面的积分
$$\int_{3}^6 \frac{1}{10\sqrt{2\pi}}e^{-\frac{(x-1)^2}{2\cdot10^2}}dx$$
<<>>=
runs <- 100000
sims <- rnorm(runs,mean=1,sd=10)
mc.integral <- sum(sims >= 3 & sims <= 6)/runs
mc.integral
mc.fun<-function(x){
  1/(10*sqrt(2*pi))*exp(-(x-1)^2/(2*10^2))
}
integrate(mc.fun,3,6)
@
\end{frame}



\begin{frame}[fragile]
\frametitle{Approximating the Binomial Distribution}
We flip a coin 10 times and we want to know the probability of getting more than 3 heads.
<<size="scriptsize">>=
runs <- 100000
#one.trail simulates a single round of toss 10 coins
#and returns true if the number of heads is > 3
one.trial <- function(){
  sum(sample(c(0,1),10,replace=T)) > 3
}
#now we repeat that trial 'runs' times.
mc.binom <- sum(replicate(runs,one.trial()))/runs
mc.binom
pbinom(3,10,0.5,lower.tail=FALSE)
@
\end{frame}



\subsection{EM算法}

\begin{frame}[fragile]
\frametitle{Introduction}
\begin{definition}{\textbf{EM Algorithm}}
a general approach to iterative computation of maximum-likelihood estimates when the observations can be viewed as incomplete data.
\end{definition}

\begin{enumerate}
  \item including missing value situations  
  \item applications to grouped, censored or truncated data
  \item finite mixture models  
  \item variance component estimation
  \item hyperparameter estimation  
  \item iteratively reweighted least squares 
  \item factor analysis  
\end{enumerate}  
 
\end{frame}


\begin{frame}[fragile]
\frametitle{Why EM ?}
\framesubtitle{有限混合模型(高斯正态混合)}

样本$x_1,x_2,...,x_n$取自密度函数为$f(x)$的总体，$f(x)$由$m$个正态分布$N(\mu_i,\sigma_{i}^{2}),i=1,2,...,m$分别以比例$p_i$混合。

\begin{equation}
\begin{aligned}
& f(x) = \sum_{i=1}^{m}p_i f_i (x) \\
& f_i (x) = \frac{1}{\sqrt{2\pi}\sigma_i} e^{-\frac{(x-\mu_i)^2}{2\sigma_{i}^{2}}} \\
& \sum_{i=1}^{m}p_i = 1
\end{aligned}
\end{equation}
 
{\color{red}Goal} 根据样本$x_1,x_2,...,x_n$估计总体的参数$\mu_i,\sigma_{i}^{2},p_i,i=1,...,m$

\end{frame}

\begin{frame}[fragile]
\frametitle{最大似然估计}
似然函数
$$L(x_i;\mu_i,\sigma_{i}^{2},p_i)= \prod_{j=1}^{n}f(x_j)$$
对数似然函数
$$logL(x_i;\mu_i,\sigma_{i}^{2},p_i)= \sum_{j=1}^{n}log(\sum_{i=1}^{m}p_i f_i (x_j))$$
对数似然方程组
\begin{equation}
\begin{aligned}
\frac{\partial logL(x_i;\mu_i,\sigma_{i}^{2},p_i)}{\partial p_i} &= \sum_{j=1}^{n} \frac{f_i (x_j)}{\sum_{i=1}^{m}p_i f_i (x_j)} =0 \\
\frac{\partial logL(x_i;\mu_i,\sigma_{i}^{2},p_i)}{\partial \mu_i} &= \sum_{j=1}^{n} \frac{p_i f_i (x_j) \frac{x_j-\mu_i}{\sigma_{i}^{2}}} {\sum_{i=1}^{m}p_i f_i (x_j)} =0 \\
\frac{\partial logL(x_i;\mu_i,\sigma_{i}^{2},p_i)}{\partial \sigma_{i}^{2}} &= \sum_{j=1}^{n} \frac{p_i f_i (x_j) \frac{(x_j-\mu_i)^2-\sigma_{i}^{2}}{2\sigma_{i}^{4}}} {\sum_{i=1}^{m}p_i f_i (x_j)} =0
\end{aligned}
\end{equation}
\end{frame}



\begin{frame}[fragile]
\frametitle{非线性对数似然方程组的挑战}
将$\sum_{i=1}^{m}p_i=1$代入(4)，可得到共$3m-1$个方程，$3m-1$个未知数。\\
显然这是一个非线性方程组，{\color{red}怎么解?}
\begin{enumerate}
 \item 精确解的数学理论(存在性、唯一性等)不清楚
 \item 有些算法的原理在多维情形下不成立，如二分法
 \item 有些算法能推广到多维，但如何推广值得研究，如牛顿迭代和割线法
 \item 当方程组含有许多方程时，每步迭代的运算量大成为突出问题
\end{enumerate}
对于多项式方程组，同伦算法\textsuperscript{\cite{homotopy}}(或称延拓法)可以解，
但是对于更一般类型，没有严格的理论基础！
\end{frame}



\subsection{GA算法}

\begin{frame}[fragile]
\frametitle{Genetic Algorithms(遗传算法\textsuperscript{\cite{R-GA}})}
\begin{enumerate}
  \item Genetic algorithms (GAs) are stochastic search algorithms inspired by the basic principles
of biological evolution(生物进化) and natural selection(自然选择).
  \item GAs simulate the evolution of living organisms, where the fittest individuals dominate over the weaker ones, by mimicking the biological mechanisms of evolution, such as selection(选择), crossover(杂交) and mutation(突变).
  \item GAs have been successfully applied to solve optimization problems, both for continuous (whether
differentiable or not) and discrete functions.
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\frametitle{GA包介绍}
\begin{itemize}
  \item 目标函数可离散或连续
  \item (不)带限制条件
  \item 可以自定义目标函数
  \item 有可供选择的基因操作
  \item 可以自定义基因操作，并对其评估
  \item GA算法可串行或并行
\end{itemize}  
<<message=FALSE>>=
library(foreach)
library(iterators)
library(GA)
args("ga")
@
\end{frame}



\begin{frame}[fragile]
\frametitle{其他R包}
\begin{itemize}
  \item gafit：Genetic Algorithm for Curve Fitting(已经不维护) 
  \item galts：Genetic algorithms and C-steps based LTS (Least Trimmed Squares) estimation. 
  \item mcga：Machine Coded Genetic Algorithms for Real-Valued Optimization Problems.
  \item rgenoud：R Version of GENetic Optimization Using Derivatives. 
  \item genalg：R based genetic algorithm for binary and floating point chromosomes.
  \item DEoptim：Implements the differential evolution algorithm for global optimization of a
        real-valued function of a real-valued parameter vector.
\end{itemize}   
\end{frame}



\begin{frame}[fragile]
\frametitle{MC方法小结}
\begin{center}
\smartdiagram[descriptive diagram]{
{step 1,产生随机数},
{step 2, {从已知分布抽样}},
{step 3, 计算相应统计量},
{step 4, {重复上述过程10000次}},
}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{数值算法VS概率算法}
~~~~如果数值算法能解，就不用概率算法，数值算法效率高，精度高！\\
但是，现实问题很复杂，唱主角的往往是概率算法，不过，数值算法依然在局部搜索中发挥重要作用，在概率算法中结合数值算法是现在研究的主流！
\end{frame}



\begin{frame}[fragile]
\frametitle{工具}
  \begin{description}
    \item[计算] {\color{red}\textbf{R}}\footnote{\url{https://www.r-project.org/}} 
                 %\textbf{\pbdR}\footnote{\url{http://r-pbd.org/}}
    \item[绘图] graphics %ggplot2 %\footnote{\url{http://ggplot2.org/}} 
    \item[渲染] {\color{blue}\textbf{Cairo}} %\footnote{\url{http://www.cairographics.org/}} 
    \item[排版] \TeX{} %knitr %\footnote{\url{http://yihui.name/knitr/}} 
                %pandoc %\footnote{\url{http://www.pandoc.org/}}
    \item[编辑] \textbf{\LyX{}}\footnote{\url{http://www.lyx.org/}} RStudio\footnote{\url{https://www.rstudio.com/}}
  \end{description}
\end{frame}


\begin{frame}[allowframebreaks]{部分参考文献}
\scriptsize
% \bibliographystyle{apalike}
\bibliographystyle{abbrv}
\bibliography{optimization.bib} 
\end{frame}


\begin{frame}[fragile]
\frametitle{Thanks for your attention!}
\framesubtitle{Q \& A}
<<echo=FALSE,fig.align='center',fig.width=10,fig.height=6.5>>=
QQ=c(2,4,4,2,1,3,7,0,4,5)
Tel<-c(1,8,8,1,0,6,5,2,9,0,3)

op<-par(mar=c(2,4,2,1),mfrow=c(2,1))
plot(QQ,main = "QQ",xlab = "",ylab = "Digits",type = "h",col=QQ,lwd=2)
points(QQ,pch=19,cex=1.5)

plot(Tel,main = "Mobile Phone",xlab = "",ylab = "Digits",type = "h",col=Tel,lwd=2)
points(Tel,pch=19,cex=1.5)

par(op)
@
\end{frame}

\end{document}